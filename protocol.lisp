
;;;;    protocol.lisp

;;; Generated by the protocol buffer compiler.  DO NOT EDIT!


(cl:in-package #:common-lisp-user)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (unless (find-package '#:cl-rethinkdb-proto)
    (make-package '#:cl-rethinkdb-proto :use nil)))
(in-package #:cl-rethinkdb-proto)
(cl:declaim #.com.google.base:*optimize-default*)

(cl:deftype version-dummy-version () '(cl:member 1063369270 1915781601))
(cl:export 'version-dummy-version)

(cl:defconstant +version-dummy-version-v0-1+ 1063369270)
(cl:export '+version-dummy-version-v0-1+)
(cl:defconstant +version-dummy-version-v0-2+ 1915781601)
(cl:export '+version-dummy-version-v0-2+)

(cl:defconstant +minimum-version-dummy-version+ +version-dummy-version-v0-1+)
(cl:export '+minimum-version-dummy-version+)
(cl:defconstant +maximum-version-dummy-version+ +version-dummy-version-v0-2+)
(cl:export '+maximum-version-dummy-version+)

(cl:deftype query-query-type () '(cl:member 1 2 3))
(cl:export 'query-query-type)

(cl:defconstant +query-query-type-start+ 1)
(cl:export '+query-query-type-start+)
(cl:defconstant +query-query-type-continue+ 2)
(cl:export '+query-query-type-continue+)
(cl:defconstant +query-query-type-stop+ 3)
(cl:export '+query-query-type-stop+)

(cl:defconstant +minimum-query-query-type+ +query-query-type-start+)
(cl:export '+minimum-query-query-type+)
(cl:defconstant +maximum-query-query-type+ +query-query-type-stop+)
(cl:export '+maximum-query-query-type+)

(cl:deftype frame-frame-type () '(cl:member 1 2))
(cl:export 'frame-frame-type)

(cl:defconstant +frame-frame-type-pos+ 1)
(cl:export '+frame-frame-type-pos+)
(cl:defconstant +frame-frame-type-opt+ 2)
(cl:export '+frame-frame-type-opt+)

(cl:defconstant +minimum-frame-frame-type+ +frame-frame-type-pos+)
(cl:export '+minimum-frame-frame-type+)
(cl:defconstant +maximum-frame-frame-type+ +frame-frame-type-opt+)
(cl:export '+maximum-frame-frame-type+)

(cl:deftype response-response-type () '(cl:member 1 2 3 16 17 18))
(cl:export 'response-response-type)

(cl:defconstant +response-response-type-success-atom+ 1)
(cl:export '+response-response-type-success-atom+)
(cl:defconstant +response-response-type-success-sequence+ 2)
(cl:export '+response-response-type-success-sequence+)
(cl:defconstant +response-response-type-success-partial+ 3)
(cl:export '+response-response-type-success-partial+)
(cl:defconstant +response-response-type-client-error+ 16)
(cl:export '+response-response-type-client-error+)
(cl:defconstant +response-response-type-compile-error+ 17)
(cl:export '+response-response-type-compile-error+)
(cl:defconstant +response-response-type-runtime-error+ 18)
(cl:export '+response-response-type-runtime-error+)

(cl:defconstant +minimum-response-response-type+ +response-response-type-success-atom+)
(cl:export '+minimum-response-response-type+)
(cl:defconstant +maximum-response-response-type+ +response-response-type-runtime-error+)
(cl:export '+maximum-response-response-type+)

(cl:deftype datum-datum-type () '(cl:member 1 2 3 4 5 6))
(cl:export 'datum-datum-type)

(cl:defconstant +datum-datum-type-r-null+ 1)
(cl:export '+datum-datum-type-r-null+)
(cl:defconstant +datum-datum-type-r-bool+ 2)
(cl:export '+datum-datum-type-r-bool+)
(cl:defconstant +datum-datum-type-r-num+ 3)
(cl:export '+datum-datum-type-r-num+)
(cl:defconstant +datum-datum-type-r-str+ 4)
(cl:export '+datum-datum-type-r-str+)
(cl:defconstant +datum-datum-type-r-array+ 5)
(cl:export '+datum-datum-type-r-array+)
(cl:defconstant +datum-datum-type-r-object+ 6)
(cl:export '+datum-datum-type-r-object+)

(cl:defconstant +minimum-datum-datum-type+ +datum-datum-type-r-null+)
(cl:export '+minimum-datum-datum-type+)
(cl:defconstant +maximum-datum-datum-type+ +datum-datum-type-r-object+)
(cl:export '+maximum-datum-datum-type+)

(cl:deftype term-term-type () '(cl:member 1 2 3 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98))
(cl:export 'term-term-type)

(cl:defconstant +term-term-type-datum+ 1)
(cl:export '+term-term-type-datum+)
(cl:defconstant +term-term-type-make-array+ 2)
(cl:export '+term-term-type-make-array+)
(cl:defconstant +term-term-type-make-obj+ 3)
(cl:export '+term-term-type-make-obj+)
(cl:defconstant +term-term-type-var+ 10)
(cl:export '+term-term-type-var+)
(cl:defconstant +term-term-type-javascript+ 11)
(cl:export '+term-term-type-javascript+)
(cl:defconstant +term-term-type-error+ 12)
(cl:export '+term-term-type-error+)
(cl:defconstant +term-term-type-implicit-var+ 13)
(cl:export '+term-term-type-implicit-var+)
(cl:defconstant +term-term-type-db+ 14)
(cl:export '+term-term-type-db+)
(cl:defconstant +term-term-type-table+ 15)
(cl:export '+term-term-type-table+)
(cl:defconstant +term-term-type-get+ 16)
(cl:export '+term-term-type-get+)
(cl:defconstant +term-term-type-get-all+ 78)
(cl:export '+term-term-type-get-all+)
(cl:defconstant +term-term-type-eq+ 17)
(cl:export '+term-term-type-eq+)
(cl:defconstant +term-term-type-ne+ 18)
(cl:export '+term-term-type-ne+)
(cl:defconstant +term-term-type-lt+ 19)
(cl:export '+term-term-type-lt+)
(cl:defconstant +term-term-type-le+ 20)
(cl:export '+term-term-type-le+)
(cl:defconstant +term-term-type-gt+ 21)
(cl:export '+term-term-type-gt+)
(cl:defconstant +term-term-type-ge+ 22)
(cl:export '+term-term-type-ge+)
(cl:defconstant +term-term-type-not+ 23)
(cl:export '+term-term-type-not+)
(cl:defconstant +term-term-type-add+ 24)
(cl:export '+term-term-type-add+)
(cl:defconstant +term-term-type-sub+ 25)
(cl:export '+term-term-type-sub+)
(cl:defconstant +term-term-type-mul+ 26)
(cl:export '+term-term-type-mul+)
(cl:defconstant +term-term-type-div+ 27)
(cl:export '+term-term-type-div+)
(cl:defconstant +term-term-type-mod+ 28)
(cl:export '+term-term-type-mod+)
(cl:defconstant +term-term-type-append+ 29)
(cl:export '+term-term-type-append+)
(cl:defconstant +term-term-type-prepend+ 80)
(cl:export '+term-term-type-prepend+)
(cl:defconstant +term-term-type-difference+ 95)
(cl:export '+term-term-type-difference+)
(cl:defconstant +term-term-type-set-insert+ 88)
(cl:export '+term-term-type-set-insert+)
(cl:defconstant +term-term-type-set-intersection+ 89)
(cl:export '+term-term-type-set-intersection+)
(cl:defconstant +term-term-type-set-union+ 90)
(cl:export '+term-term-type-set-union+)
(cl:defconstant +term-term-type-set-difference+ 91)
(cl:export '+term-term-type-set-difference+)
(cl:defconstant +term-term-type-slice+ 30)
(cl:export '+term-term-type-slice+)
(cl:defconstant +term-term-type-skip+ 70)
(cl:export '+term-term-type-skip+)
(cl:defconstant +term-term-type-limit+ 71)
(cl:export '+term-term-type-limit+)
(cl:defconstant +term-term-type-indexes-of+ 87)
(cl:export '+term-term-type-indexes-of+)
(cl:defconstant +term-term-type-contains+ 93)
(cl:export '+term-term-type-contains+)
(cl:defconstant +term-term-type-get-field+ 31)
(cl:export '+term-term-type-get-field+)
(cl:defconstant +term-term-type-keys+ 94)
(cl:export '+term-term-type-keys+)
(cl:defconstant +term-term-type-has-fields+ 32)
(cl:export '+term-term-type-has-fields+)
(cl:defconstant +term-term-type-with-fields+ 96)
(cl:export '+term-term-type-with-fields+)
(cl:defconstant +term-term-type-pluck+ 33)
(cl:export '+term-term-type-pluck+)
(cl:defconstant +term-term-type-without+ 34)
(cl:export '+term-term-type-without+)
(cl:defconstant +term-term-type-merge+ 35)
(cl:export '+term-term-type-merge+)
(cl:defconstant +term-term-type-between+ 36)
(cl:export '+term-term-type-between+)
(cl:defconstant +term-term-type-reduce+ 37)
(cl:export '+term-term-type-reduce+)
(cl:defconstant +term-term-type-map+ 38)
(cl:export '+term-term-type-map+)
(cl:defconstant +term-term-type-filter+ 39)
(cl:export '+term-term-type-filter+)
(cl:defconstant +term-term-type-concatmap+ 40)
(cl:export '+term-term-type-concatmap+)
(cl:defconstant +term-term-type-orderby+ 41)
(cl:export '+term-term-type-orderby+)
(cl:defconstant +term-term-type-distinct+ 42)
(cl:export '+term-term-type-distinct+)
(cl:defconstant +term-term-type-count+ 43)
(cl:export '+term-term-type-count+)
(cl:defconstant +term-term-type-is-empty+ 86)
(cl:export '+term-term-type-is-empty+)
(cl:defconstant +term-term-type-union+ 44)
(cl:export '+term-term-type-union+)
(cl:defconstant +term-term-type-nth+ 45)
(cl:export '+term-term-type-nth+)
(cl:defconstant +term-term-type-grouped-map-reduce+ 46)
(cl:export '+term-term-type-grouped-map-reduce+)
(cl:defconstant +term-term-type-groupby+ 47)
(cl:export '+term-term-type-groupby+)
(cl:defconstant +term-term-type-inner-join+ 48)
(cl:export '+term-term-type-inner-join+)
(cl:defconstant +term-term-type-outer-join+ 49)
(cl:export '+term-term-type-outer-join+)
(cl:defconstant +term-term-type-eq-join+ 50)
(cl:export '+term-term-type-eq-join+)
(cl:defconstant +term-term-type-zip+ 72)
(cl:export '+term-term-type-zip+)
(cl:defconstant +term-term-type-insert-at+ 82)
(cl:export '+term-term-type-insert-at+)
(cl:defconstant +term-term-type-delete-at+ 83)
(cl:export '+term-term-type-delete-at+)
(cl:defconstant +term-term-type-change-at+ 84)
(cl:export '+term-term-type-change-at+)
(cl:defconstant +term-term-type-splice-at+ 85)
(cl:export '+term-term-type-splice-at+)
(cl:defconstant +term-term-type-coerce-to+ 51)
(cl:export '+term-term-type-coerce-to+)
(cl:defconstant +term-term-type-typeof+ 52)
(cl:export '+term-term-type-typeof+)
(cl:defconstant +term-term-type-update+ 53)
(cl:export '+term-term-type-update+)
(cl:defconstant +term-term-type-delete+ 54)
(cl:export '+term-term-type-delete+)
(cl:defconstant +term-term-type-replace+ 55)
(cl:export '+term-term-type-replace+)
(cl:defconstant +term-term-type-insert+ 56)
(cl:export '+term-term-type-insert+)
(cl:defconstant +term-term-type-db-create+ 57)
(cl:export '+term-term-type-db-create+)
(cl:defconstant +term-term-type-db-drop+ 58)
(cl:export '+term-term-type-db-drop+)
(cl:defconstant +term-term-type-db-list+ 59)
(cl:export '+term-term-type-db-list+)
(cl:defconstant +term-term-type-table-create+ 60)
(cl:export '+term-term-type-table-create+)
(cl:defconstant +term-term-type-table-drop+ 61)
(cl:export '+term-term-type-table-drop+)
(cl:defconstant +term-term-type-table-list+ 62)
(cl:export '+term-term-type-table-list+)
(cl:defconstant +term-term-type-index-create+ 75)
(cl:export '+term-term-type-index-create+)
(cl:defconstant +term-term-type-index-drop+ 76)
(cl:export '+term-term-type-index-drop+)
(cl:defconstant +term-term-type-index-list+ 77)
(cl:export '+term-term-type-index-list+)
(cl:defconstant +term-term-type-funcall+ 64)
(cl:export '+term-term-type-funcall+)
(cl:defconstant +term-term-type-branch+ 65)
(cl:export '+term-term-type-branch+)
(cl:defconstant +term-term-type-any+ 66)
(cl:export '+term-term-type-any+)
(cl:defconstant +term-term-type-all+ 67)
(cl:export '+term-term-type-all+)
(cl:defconstant +term-term-type-foreach+ 68)
(cl:export '+term-term-type-foreach+)
(cl:defconstant +term-term-type-func+ 69)
(cl:export '+term-term-type-func+)
(cl:defconstant +term-term-type-asc+ 73)
(cl:export '+term-term-type-asc+)
(cl:defconstant +term-term-type-desc+ 74)
(cl:export '+term-term-type-desc+)
(cl:defconstant +term-term-type-info+ 79)
(cl:export '+term-term-type-info+)
(cl:defconstant +term-term-type-match+ 97)
(cl:export '+term-term-type-match+)
(cl:defconstant +term-term-type-sample+ 81)
(cl:export '+term-term-type-sample+)
(cl:defconstant +term-term-type-default+ 92)
(cl:export '+term-term-type-default+)
(cl:defconstant +term-term-type-json+ 98)
(cl:export '+term-term-type-json+)

(cl:defconstant +minimum-term-term-type+ +term-term-type-datum+)
(cl:export '+minimum-term-term-type+)
(cl:defconstant +maximum-term-term-type+ +term-term-type-json+)
(cl:export '+maximum-term-term-type+)

(cl:defclass version-dummy (pb:protocol-buffer)
  (
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'version-dummy)


(cl:defmethod cl:print-object ((self version-dummy) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      ))
  (cl:values))

(cl:defmethod pb:clear ((self version-dummy))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self version-dummy))
  cl:t)

(cl:defmethod pb:octet-size ((self version-dummy))
  (cl:let ((size 0))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self version-dummy) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  index)

(cl:defmethod pb:merge-from-array ((self version-dummy) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self version-dummy) (from version-dummy))
)


(cl:defclass query-assoc-pair (pb:protocol-buffer)
  (
  (key
   :accessor key
   :initform (pb:string-field "")
   :type pb::%sf%)
  (val
   :writer (cl:setf val)
   :initform cl:nil
   :type (cl:or cl:null cl-rethinkdb-proto::term))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'query-assoc-pair)

(cl:export 'key)


(cl:defmethod (cl:setf key) :after (x (self query-assoc-pair))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-key)
  (cl:defgeneric has-key (proto)))
(cl:defmethod has-key ((self query-assoc-pair))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-key)

(cl:unless (cl:fboundp 'clear-key)
  (cl:defgeneric clear-key (proto)))
(cl:defmethod clear-key ((self query-assoc-pair))
  (cl:setf (cl:slot-value self 'key) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-key)

(cl:export 'val)

(cl:unless (cl:fboundp 'val)
  (cl:defgeneric val (proto)))
(cl:defmethod val ((self query-assoc-pair))
  (cl:let ((result (cl:slot-value self 'val)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'cl-rethinkdb-proto::term))
      (cl:setf (cl:slot-value self 'val) result))
      (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf val) :after (x (self query-assoc-pair))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-val)
  (cl:defgeneric has-val (proto)))
(cl:defmethod has-val ((self query-assoc-pair))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-val)

(cl:unless (cl:fboundp 'clear-val)
  (cl:defgeneric clear-val (proto)))
(cl:defmethod clear-val ((self query-assoc-pair))
  (cl:setf (cl:slot-value self 'val) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-val)



(cl:defclass query (pb:protocol-buffer)
  (
  (type
   :accessor type
   :initform cl-rethinkdb-proto::+query-query-type-start+
   :type cl-rethinkdb-proto::query-query-type)
  (query
   :writer (cl:setf query)
   :initform cl:nil
   :type (cl:or cl:null cl-rethinkdb-proto::term))
  (token
   :accessor token
   :initform 0
   :type (cl:signed-byte 64))
  (obsolete-noreply
   :accessor obsolete-noreply
   :initform cl:nil
   :type cl:boolean)
  (global-optargs
   :accessor global-optargs
   :initform (cl:make-array
              0
              :element-type 'cl-rethinkdb-proto::query-assoc-pair
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector cl-rethinkdb-proto::query-assoc-pair))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 5))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'query)

(cl:export 'type)


(cl:defmethod (cl:setf type) :after (x (self query))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-type)
  (cl:defgeneric has-type (proto)))
(cl:defmethod has-type ((self query))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-type)

(cl:unless (cl:fboundp 'clear-type)
  (cl:defgeneric clear-type (proto)))
(cl:defmethod clear-type ((self query))
  (cl:setf (cl:slot-value self 'type) cl-rethinkdb-proto::+query-query-type-start+)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-type)

(cl:export 'query)

(cl:unless (cl:fboundp 'query)
  (cl:defgeneric query (proto)))
(cl:defmethod query ((self query))
  (cl:let ((result (cl:slot-value self 'query)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'cl-rethinkdb-proto::term))
      (cl:setf (cl:slot-value self 'query) result))
      (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf query) :after (x (self query))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-query)
  (cl:defgeneric has-query (proto)))
(cl:defmethod has-query ((self query))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-query)

(cl:unless (cl:fboundp 'clear-query)
  (cl:defgeneric clear-query (proto)))
(cl:defmethod clear-query ((self query))
  (cl:setf (cl:slot-value self 'query) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-query)

(cl:export 'token)


(cl:defmethod (cl:setf token) :after (x (self query))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-token)
  (cl:defgeneric has-token (proto)))
(cl:defmethod has-token ((self query))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-token)

(cl:unless (cl:fboundp 'clear-token)
  (cl:defgeneric clear-token (proto)))
(cl:defmethod clear-token ((self query))
  (cl:setf (cl:slot-value self 'token) 0)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-token)

(cl:export 'obsolete-noreply)


(cl:defmethod (cl:setf obsolete-noreply) :after (x (self query))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-obsolete-noreply)
  (cl:defgeneric has-obsolete-noreply (proto)))
(cl:defmethod has-obsolete-noreply ((self query))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-obsolete-noreply)

(cl:unless (cl:fboundp 'clear-obsolete-noreply)
  (cl:defgeneric clear-obsolete-noreply (proto)))
(cl:defmethod clear-obsolete-noreply ((self query))
  (cl:setf (cl:slot-value self 'obsolete-noreply) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-obsolete-noreply)

(cl:export 'global-optargs)

(cl:unless (cl:fboundp 'clear-global-optargs)
  (cl:defgeneric clear-global-optargs (proto)))
(cl:defmethod clear-global-optargs ((self query))
  (cl:setf (cl:slot-value self 'global-optargs)
           (cl:make-array 0 :element-type 'cl-rethinkdb-proto::query-assoc-pair
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-global-optargs)


(cl:defmethod cl:print-object ((self query-assoc-pair) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_key: ~s" (key self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_val: ~s" (val self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self query-assoc-pair))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'key) (pb:string-field "")))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'val) cl:nil))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self query-assoc-pair))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:unless (pb:is-initialized (cl:slot-value self 'val))
      (cl:return-from pb:is-initialized cl:nil)))
  cl:t)

(cl:defmethod pb:octet-size ((self query-assoc-pair))
  (cl:let ((size 0))
    ;; optional string key = 1;
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'key))))
        (cl:+ s (varint:length32 s)))))
    ;; optional .Term val = 2;
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'val))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self query-assoc-pair) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional string key = 1;
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'key) 'pb::%octets%))))
  ;; optional .Term val = 2;
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'val) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'val) buffer index limit)))
  index)

(cl:defmethod pb:merge-from-array ((self query-assoc-pair) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; optional string key = 1;
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'key) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional .Term val = 2;
        ((18)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'val)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'cl-rethinkdb-proto::term))
                (cl:setf (cl:slot-value self 'val) message)
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self query-assoc-pair) (from query-assoc-pair))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'key) (cl:slot-value from 'key))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'val)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'cl-rethinkdb-proto::term))
        (cl:setf (cl:slot-value self 'val) message)
        (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'val))))
)



(cl:defmethod cl:print-object ((self query) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_type: ~s" (type self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_query: ~s" (query self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_token: ~s" (token self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_obsolete-noreply: ~s" (obsolete-noreply self)))
      (cl:format stream " ~_global-optargs: ~s" (global-optargs self))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self query))
  (cl:setf (cl:slot-value self 'type) cl-rethinkdb-proto::+query-query-type-start+)
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'query) cl:nil))
  (cl:setf (cl:slot-value self 'token) 0)
  (cl:setf (cl:slot-value self 'obsolete-noreply) cl:nil)
  (cl:setf (cl:slot-value self 'global-optargs)
           (cl:make-array 0 :element-type 'cl-rethinkdb-proto::query-assoc-pair
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self query))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:unless (pb:is-initialized (cl:slot-value self 'query))
      (cl:return-from pb:is-initialized cl:nil)))
  (cl:let* ((x (cl:slot-value self 'global-optargs))
            (length (cl:length x)))
    (cl:dotimes (i length)
      (cl:unless (pb:is-initialized (cl:aref x i))
        (cl:return-from pb:is-initialized cl:nil))))
  cl:t)

(cl:defmethod pb:octet-size ((self query))
  (cl:let ((size 0))
    ;; optional .Query.QueryType type = 1;
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'type)))))
    ;; optional .Term query = 2;
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'query))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; optional int64 token = 3;
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'token))))))
    ;; optional bool OBSOLETE_noreply = 4 [default = false];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 1)))
    ;; repeated .Query.AssocPair global_optargs = 6;
    (cl:let* ((v (cl:slot-value self 'global-optargs))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self query) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional .Query.QueryType type = 1;
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (cl:ldb (cl:byte 64 0) (cl:slot-value self 'type)))))
  ;; optional .Term query = 2;
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'query) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'query) buffer index limit)))
  ;; optional int64 token = 3;
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 24))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'token)))))
  ;; optional bool OBSOLETE_noreply = 4 [default = false];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 32))
    (cl:setf index (wire-format:write-boolean-carefully buffer index limit (cl:slot-value self 'obsolete-noreply))))
  ;; repeated .Query.AssocPair global_optargs = 6;
  (cl:let* ((v (cl:slot-value self 'global-optargs))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 50))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  index)

(cl:defmethod pb:merge-from-array ((self query) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; optional .Query.QueryType type = 1;
        ((8)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            ;; XXXXX: when valid, set field, else add to unknown fields
            (cl:setf (cl:slot-value self 'type) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional .Term query = 2;
        ((18)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'query)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'cl-rethinkdb-proto::term))
                (cl:setf (cl:slot-value self 'query) message)
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; optional int64 token = 3;
        ((24)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'token) value)
            (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional bool OBSOLETE_noreply = 4 [default = false];
        ((32)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-boolean-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'obsolete-noreply) value)
            (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; repeated .Query.AssocPair global_optargs = 6;
        ((50)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'cl-rethinkdb-proto::query-assoc-pair)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'global-optargs)))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self query) (from query))
  (cl:let* ((v (cl:slot-value self 'global-optargs))
            (vf (cl:slot-value from 'global-optargs))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'type) (cl:slot-value from 'type))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'query)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'cl-rethinkdb-proto::term))
        (cl:setf (cl:slot-value self 'query) message)
        (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'query))))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'token) (cl:slot-value from 'token))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'obsolete-noreply) (cl:slot-value from 'obsolete-noreply))
    (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass frame (pb:protocol-buffer)
  (
  (type
   :accessor type
   :initform cl-rethinkdb-proto::+frame-frame-type-pos+
   :type cl-rethinkdb-proto::frame-frame-type)
  (pos
   :accessor pos
   :initform 0
   :type (cl:signed-byte 64))
  (opt
   :accessor opt
   :initform (pb:string-field "")
   :type pb::%sf%)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 3))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'frame)

(cl:export 'type)


(cl:defmethod (cl:setf type) :after (x (self frame))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-type)
  (cl:defgeneric has-type (proto)))
(cl:defmethod has-type ((self frame))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-type)

(cl:unless (cl:fboundp 'clear-type)
  (cl:defgeneric clear-type (proto)))
(cl:defmethod clear-type ((self frame))
  (cl:setf (cl:slot-value self 'type) cl-rethinkdb-proto::+frame-frame-type-pos+)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-type)

(cl:export 'pos)


(cl:defmethod (cl:setf pos) :after (x (self frame))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-pos)
  (cl:defgeneric has-pos (proto)))
(cl:defmethod has-pos ((self frame))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-pos)

(cl:unless (cl:fboundp 'clear-pos)
  (cl:defgeneric clear-pos (proto)))
(cl:defmethod clear-pos ((self frame))
  (cl:setf (cl:slot-value self 'pos) 0)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-pos)

(cl:export 'opt)


(cl:defmethod (cl:setf opt) :after (x (self frame))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-opt)
  (cl:defgeneric has-opt (proto)))
(cl:defmethod has-opt ((self frame))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-opt)

(cl:unless (cl:fboundp 'clear-opt)
  (cl:defgeneric clear-opt (proto)))
(cl:defmethod clear-opt ((self frame))
  (cl:setf (cl:slot-value self 'opt) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-opt)


(cl:defmethod cl:print-object ((self frame) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_type: ~s" (type self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_pos: ~s" (pos self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_opt: ~s" (opt self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self frame))
  (cl:setf (cl:slot-value self 'type) cl-rethinkdb-proto::+frame-frame-type-pos+)
  (cl:setf (cl:slot-value self 'pos) 0)
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'opt) (pb:string-field "")))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self frame))
  cl:t)

(cl:defmethod pb:octet-size ((self frame))
  (cl:let ((size 0))
    ;; optional .Frame.FrameType type = 1;
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'type)))))
    ;; optional int64 pos = 2;
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'pos))))))
    ;; optional string opt = 3;
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'opt))))
        (cl:+ s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self frame) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional .Frame.FrameType type = 1;
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (cl:ldb (cl:byte 64 0) (cl:slot-value self 'type)))))
  ;; optional int64 pos = 2;
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'pos)))))
  ;; optional string opt = 3;
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'opt) 'pb::%octets%))))
  index)

(cl:defmethod pb:merge-from-array ((self frame) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; optional .Frame.FrameType type = 1;
        ((8)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            ;; XXXXX: when valid, set field, else add to unknown fields
            (cl:setf (cl:slot-value self 'type) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional int64 pos = 2;
        ((16)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'pos) value)
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional string opt = 3;
        ((26)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'opt) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self frame) (from frame))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'type) (cl:slot-value from 'type))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'pos) (cl:slot-value from 'pos))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'opt) (cl:slot-value from 'opt))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass backtrace (pb:protocol-buffer)
  (
  (frames
   :accessor frames
   :initform (cl:make-array
              0
              :element-type 'cl-rethinkdb-proto::frame
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector cl-rethinkdb-proto::frame))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 1))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'backtrace)

(cl:export 'frames)

(cl:unless (cl:fboundp 'clear-frames)
  (cl:defgeneric clear-frames (proto)))
(cl:defmethod clear-frames ((self backtrace))
  (cl:setf (cl:slot-value self 'frames)
           (cl:make-array 0 :element-type 'cl-rethinkdb-proto::frame
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-frames)


(cl:defmethod cl:print-object ((self backtrace) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:format stream " ~_frames: ~s" (frames self))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self backtrace))
  (cl:setf (cl:slot-value self 'frames)
           (cl:make-array 0 :element-type 'cl-rethinkdb-proto::frame
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self backtrace))
  cl:t)

(cl:defmethod pb:octet-size ((self backtrace))
  (cl:let ((size 0))
    ;; repeated .Frame frames = 1;
    (cl:let* ((v (cl:slot-value self 'frames))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self backtrace) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; repeated .Frame frames = 1;
  (cl:let* ((v (cl:slot-value self 'frames))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  index)

(cl:defmethod pb:merge-from-array ((self backtrace) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; repeated .Frame frames = 1;
        ((10)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'cl-rethinkdb-proto::frame)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'frames)))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self backtrace) (from backtrace))
  (cl:let* ((v (cl:slot-value self 'frames))
            (vf (cl:slot-value from 'frames))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
)


(cl:defclass response (pb:protocol-buffer)
  (
  (type
   :accessor type
   :initform cl-rethinkdb-proto::+response-response-type-success-atom+
   :type cl-rethinkdb-proto::response-response-type)
  (token
   :accessor token
   :initform 0
   :type (cl:signed-byte 64))
  (response
   :accessor response
   :initform (cl:make-array
              0
              :element-type 'cl-rethinkdb-proto::datum
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector cl-rethinkdb-proto::datum))
  (backtrace
   :writer (cl:setf backtrace)
   :initform cl:nil
   :type (cl:or cl:null cl-rethinkdb-proto::backtrace))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 4))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'response)

(cl:export 'type)


(cl:defmethod (cl:setf type) :after (x (self response))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-type)
  (cl:defgeneric has-type (proto)))
(cl:defmethod has-type ((self response))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-type)

(cl:unless (cl:fboundp 'clear-type)
  (cl:defgeneric clear-type (proto)))
(cl:defmethod clear-type ((self response))
  (cl:setf (cl:slot-value self 'type) cl-rethinkdb-proto::+response-response-type-success-atom+)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-type)

(cl:export 'token)


(cl:defmethod (cl:setf token) :after (x (self response))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-token)
  (cl:defgeneric has-token (proto)))
(cl:defmethod has-token ((self response))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-token)

(cl:unless (cl:fboundp 'clear-token)
  (cl:defgeneric clear-token (proto)))
(cl:defmethod clear-token ((self response))
  (cl:setf (cl:slot-value self 'token) 0)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-token)

(cl:export 'response)

(cl:unless (cl:fboundp 'clear-response)
  (cl:defgeneric clear-response (proto)))
(cl:defmethod clear-response ((self response))
  (cl:setf (cl:slot-value self 'response)
           (cl:make-array 0 :element-type 'cl-rethinkdb-proto::datum
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-response)

(cl:export 'backtrace)

(cl:unless (cl:fboundp 'backtrace)
  (cl:defgeneric backtrace (proto)))
(cl:defmethod backtrace ((self response))
  (cl:let ((result (cl:slot-value self 'backtrace)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'cl-rethinkdb-proto::backtrace))
      (cl:setf (cl:slot-value self 'backtrace) result))
      (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf backtrace) :after (x (self response))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-backtrace)
  (cl:defgeneric has-backtrace (proto)))
(cl:defmethod has-backtrace ((self response))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-backtrace)

(cl:unless (cl:fboundp 'clear-backtrace)
  (cl:defgeneric clear-backtrace (proto)))
(cl:defmethod clear-backtrace ((self response))
  (cl:setf (cl:slot-value self 'backtrace) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-backtrace)


(cl:defmethod cl:print-object ((self response) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_type: ~s" (type self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_token: ~s" (token self)))
      (cl:format stream " ~_response: ~s" (response self))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_backtrace: ~s" (backtrace self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self response))
  (cl:setf (cl:slot-value self 'type) cl-rethinkdb-proto::+response-response-type-success-atom+)
  (cl:setf (cl:slot-value self 'token) 0)
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'backtrace) cl:nil))
  (cl:setf (cl:slot-value self 'response)
           (cl:make-array 0 :element-type 'cl-rethinkdb-proto::datum
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self response))
  (cl:let* ((x (cl:slot-value self 'response))
            (length (cl:length x)))
    (cl:dotimes (i length)
      (cl:unless (pb:is-initialized (cl:aref x i))
        (cl:return-from pb:is-initialized cl:nil))))
  cl:t)

(cl:defmethod pb:octet-size ((self response))
  (cl:let ((size 0))
    ;; optional .Response.ResponseType type = 1;
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'type)))))
    ;; optional int64 token = 2;
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'token))))))
    ;; optional .Backtrace backtrace = 4;
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'backtrace))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; repeated .Datum response = 3;
    (cl:let* ((v (cl:slot-value self 'response))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self response) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional .Response.ResponseType type = 1;
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (cl:ldb (cl:byte 64 0) (cl:slot-value self 'type)))))
  ;; optional int64 token = 2;
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'token)))))
  ;; repeated .Datum response = 3;
  (cl:let* ((v (cl:slot-value self 'response))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; optional .Backtrace backtrace = 4;
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 34))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'backtrace) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'backtrace) buffer index limit)))
  index)

(cl:defmethod pb:merge-from-array ((self response) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; optional .Response.ResponseType type = 1;
        ((8)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            ;; XXXXX: when valid, set field, else add to unknown fields
            (cl:setf (cl:slot-value self 'type) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional int64 token = 2;
        ((16)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'token) value)
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; repeated .Datum response = 3;
        ((26)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'cl-rethinkdb-proto::datum)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'response)))))
        ;; optional .Backtrace backtrace = 4;
        ((34)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'backtrace)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'cl-rethinkdb-proto::backtrace))
                (cl:setf (cl:slot-value self 'backtrace) message)
                (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self response) (from response))
  (cl:let* ((v (cl:slot-value self 'response))
            (vf (cl:slot-value from 'response))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'type) (cl:slot-value from 'type))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'token) (cl:slot-value from 'token))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'backtrace)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'cl-rethinkdb-proto::backtrace))
        (cl:setf (cl:slot-value self 'backtrace) message)
        (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'backtrace))))
)


(cl:defclass datum-assoc-pair (pb:protocol-buffer)
  (
  (key
   :accessor key
   :initform (pb:string-field "")
   :type pb::%sf%)
  (val
   :writer (cl:setf val)
   :initform cl:nil
   :type (cl:or cl:null cl-rethinkdb-proto::datum))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'datum-assoc-pair)

(cl:export 'key)


(cl:defmethod (cl:setf key) :after (x (self datum-assoc-pair))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-key)
  (cl:defgeneric has-key (proto)))
(cl:defmethod has-key ((self datum-assoc-pair))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-key)

(cl:unless (cl:fboundp 'clear-key)
  (cl:defgeneric clear-key (proto)))
(cl:defmethod clear-key ((self datum-assoc-pair))
  (cl:setf (cl:slot-value self 'key) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-key)

(cl:export 'val)

(cl:unless (cl:fboundp 'val)
  (cl:defgeneric val (proto)))
(cl:defmethod val ((self datum-assoc-pair))
  (cl:let ((result (cl:slot-value self 'val)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'cl-rethinkdb-proto::datum))
      (cl:setf (cl:slot-value self 'val) result))
      (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf val) :after (x (self datum-assoc-pair))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-val)
  (cl:defgeneric has-val (proto)))
(cl:defmethod has-val ((self datum-assoc-pair))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-val)

(cl:unless (cl:fboundp 'clear-val)
  (cl:defgeneric clear-val (proto)))
(cl:defmethod clear-val ((self datum-assoc-pair))
  (cl:setf (cl:slot-value self 'val) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-val)



(cl:defclass datum (pb:protocol-buffer)
  (
  (type
   :accessor type
   :initform cl-rethinkdb-proto::+datum-datum-type-r-null+
   :type cl-rethinkdb-proto::datum-datum-type)
  (r-bool
   :accessor r-bool
   :initform cl:nil
   :type cl:boolean)
  (r-num
   :accessor r-num
   :initform 0d0
   :type cl:double-float)
  (r-str
   :accessor r-str
   :initform (pb:string-field "")
   :type pb::%sf%)
  (r-array
   :accessor r-array
   :initform (cl:make-array
              0
              :element-type 'cl-rethinkdb-proto::datum
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector cl-rethinkdb-proto::datum))
  (r-object
   :accessor r-object
   :initform (cl:make-array
              0
              :element-type 'cl-rethinkdb-proto::datum-assoc-pair
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector cl-rethinkdb-proto::datum-assoc-pair))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 6))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'datum)

(cl:export 'type)


(cl:defmethod (cl:setf type) :after (x (self datum))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-type)
  (cl:defgeneric has-type (proto)))
(cl:defmethod has-type ((self datum))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-type)

(cl:unless (cl:fboundp 'clear-type)
  (cl:defgeneric clear-type (proto)))
(cl:defmethod clear-type ((self datum))
  (cl:setf (cl:slot-value self 'type) cl-rethinkdb-proto::+datum-datum-type-r-null+)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-type)

(cl:export 'r-bool)


(cl:defmethod (cl:setf r-bool) :after (x (self datum))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-r-bool)
  (cl:defgeneric has-r-bool (proto)))
(cl:defmethod has-r-bool ((self datum))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-r-bool)

(cl:unless (cl:fboundp 'clear-r-bool)
  (cl:defgeneric clear-r-bool (proto)))
(cl:defmethod clear-r-bool ((self datum))
  (cl:setf (cl:slot-value self 'r-bool) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-r-bool)

(cl:export 'r-num)


(cl:defmethod (cl:setf r-num) :after (x (self datum))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-r-num)
  (cl:defgeneric has-r-num (proto)))
(cl:defmethod has-r-num ((self datum))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-r-num)

(cl:unless (cl:fboundp 'clear-r-num)
  (cl:defgeneric clear-r-num (proto)))
(cl:defmethod clear-r-num ((self datum))
  (cl:setf (cl:slot-value self 'r-num) 0d0)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-r-num)

(cl:export 'r-str)


(cl:defmethod (cl:setf r-str) :after (x (self datum))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-r-str)
  (cl:defgeneric has-r-str (proto)))
(cl:defmethod has-r-str ((self datum))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-r-str)

(cl:unless (cl:fboundp 'clear-r-str)
  (cl:defgeneric clear-r-str (proto)))
(cl:defmethod clear-r-str ((self datum))
  (cl:setf (cl:slot-value self 'r-str) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-r-str)

(cl:export 'r-array)

(cl:unless (cl:fboundp 'clear-r-array)
  (cl:defgeneric clear-r-array (proto)))
(cl:defmethod clear-r-array ((self datum))
  (cl:setf (cl:slot-value self 'r-array)
           (cl:make-array 0 :element-type 'cl-rethinkdb-proto::datum
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-r-array)

(cl:export 'r-object)

(cl:unless (cl:fboundp 'clear-r-object)
  (cl:defgeneric clear-r-object (proto)))
(cl:defmethod clear-r-object ((self datum))
  (cl:setf (cl:slot-value self 'r-object)
           (cl:make-array 0 :element-type 'cl-rethinkdb-proto::datum-assoc-pair
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-r-object)


(cl:defmethod cl:print-object ((self datum-assoc-pair) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_key: ~s" (key self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_val: ~s" (val self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self datum-assoc-pair))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'key) (pb:string-field "")))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'val) cl:nil))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self datum-assoc-pair))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:unless (pb:is-initialized (cl:slot-value self 'val))
      (cl:return-from pb:is-initialized cl:nil)))
  cl:t)

(cl:defmethod pb:octet-size ((self datum-assoc-pair))
  (cl:let ((size 0))
    ;; optional string key = 1;
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'key))))
        (cl:+ s (varint:length32 s)))))
    ;; optional .Datum val = 2;
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'val))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self datum-assoc-pair) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional string key = 1;
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'key) 'pb::%octets%))))
  ;; optional .Datum val = 2;
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'val) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'val) buffer index limit)))
  index)

(cl:defmethod pb:merge-from-array ((self datum-assoc-pair) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; optional string key = 1;
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'key) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional .Datum val = 2;
        ((18)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'val)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'cl-rethinkdb-proto::datum))
                (cl:setf (cl:slot-value self 'val) message)
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self datum-assoc-pair) (from datum-assoc-pair))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'key) (cl:slot-value from 'key))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'val)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'cl-rethinkdb-proto::datum))
        (cl:setf (cl:slot-value self 'val) message)
        (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'val))))
)



(cl:defmethod cl:print-object ((self datum) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_type: ~s" (type self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_r-bool: ~s" (r-bool self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_r-num: ~s" (r-num self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_r-str: ~s" (r-str self)))
      (cl:format stream " ~_r-array: ~s" (r-array self))
      (cl:format stream " ~_r-object: ~s" (r-object self))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self datum))
  (cl:setf (cl:slot-value self 'type) cl-rethinkdb-proto::+datum-datum-type-r-null+)
  (cl:setf (cl:slot-value self 'r-bool) cl:nil)
  (cl:setf (cl:slot-value self 'r-num) 0d0)
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'r-str) (pb:string-field "")))
  (cl:setf (cl:slot-value self 'r-array)
           (cl:make-array 0 :element-type 'cl-rethinkdb-proto::datum
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'r-object)
           (cl:make-array 0 :element-type 'cl-rethinkdb-proto::datum-assoc-pair
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self datum))
  (cl:let* ((x (cl:slot-value self 'r-array))
            (length (cl:length x)))
    (cl:dotimes (i length)
      (cl:unless (pb:is-initialized (cl:aref x i))
        (cl:return-from pb:is-initialized cl:nil))))
  (cl:let* ((x (cl:slot-value self 'r-object))
            (length (cl:length x)))
    (cl:dotimes (i length)
      (cl:unless (pb:is-initialized (cl:aref x i))
        (cl:return-from pb:is-initialized cl:nil))))
  cl:t)

(cl:defmethod pb:octet-size ((self datum))
  (cl:let ((size 0))
    ;; optional .Datum.DatumType type = 1;
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'type)))))
    ;; optional bool r_bool = 2;
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 1)))
    ;; optional double r_num = 3;
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 8)))
    ;; optional string r_str = 4;
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'r-str))))
        (cl:+ s (varint:length32 s)))))
    ;; repeated .Datum r_array = 5;
    (cl:let* ((v (cl:slot-value self 'r-array))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    ;; repeated .Datum.AssocPair r_object = 6;
    (cl:let* ((v (cl:slot-value self 'r-object))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self datum) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional .Datum.DatumType type = 1;
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (cl:ldb (cl:byte 64 0) (cl:slot-value self 'type)))))
  ;; optional bool r_bool = 2;
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index (wire-format:write-boolean-carefully buffer index limit (cl:slot-value self 'r-bool))))
  ;; optional double r_num = 3;
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 25))
    (cl:setf index (wire-format:write-double-float-carefully buffer index limit (cl:slot-value self 'r-num))))
  ;; optional string r_str = 4;
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 34))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'r-str) 'pb::%octets%))))
  ;; repeated .Datum r_array = 5;
  (cl:let* ((v (cl:slot-value self 'r-array))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 42))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; repeated .Datum.AssocPair r_object = 6;
  (cl:let* ((v (cl:slot-value self 'r-object))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 50))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;// Extension range [10000, 20001)
  ;DO_(_extensions_.SerializeWithCachedSizes(
  ;    10000, 20001, *this, output));

  index)

(cl:defmethod pb:merge-from-array ((self datum) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; optional .Datum.DatumType type = 1;
        ((8)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            ;; XXXXX: when valid, set field, else add to unknown fields
            (cl:setf (cl:slot-value self 'type) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional bool r_bool = 2;
        ((16)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-boolean-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'r-bool) value)
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional double r_num = 3;
        ((25)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-double-float-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'r-num) value)
            (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional string r_str = 4;
        ((34)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'r-str) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; repeated .Datum r_array = 5;
        ((42)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'cl-rethinkdb-proto::datum)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'r-array)))))
        ;; repeated .Datum.AssocPair r_object = 6;
        ((50)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'cl-rethinkdb-proto::datum-assoc-pair)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'r-object)))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self datum) (from datum))
  (cl:let* ((v (cl:slot-value self 'r-array))
            (vf (cl:slot-value from 'r-array))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'r-object))
            (vf (cl:slot-value from 'r-object))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'type) (cl:slot-value from 'type))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'r-bool) (cl:slot-value from 'r-bool))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'r-num) (cl:slot-value from 'r-num))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'r-str) (cl:slot-value from 'r-str))
    (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass term-assoc-pair (pb:protocol-buffer)
  (
  (key
   :accessor key
   :initform (pb:string-field "")
   :type pb::%sf%)
  (val
   :writer (cl:setf val)
   :initform cl:nil
   :type (cl:or cl:null cl-rethinkdb-proto::term))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'term-assoc-pair)

(cl:export 'key)


(cl:defmethod (cl:setf key) :after (x (self term-assoc-pair))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-key)
  (cl:defgeneric has-key (proto)))
(cl:defmethod has-key ((self term-assoc-pair))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-key)

(cl:unless (cl:fboundp 'clear-key)
  (cl:defgeneric clear-key (proto)))
(cl:defmethod clear-key ((self term-assoc-pair))
  (cl:setf (cl:slot-value self 'key) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-key)

(cl:export 'val)

(cl:unless (cl:fboundp 'val)
  (cl:defgeneric val (proto)))
(cl:defmethod val ((self term-assoc-pair))
  (cl:let ((result (cl:slot-value self 'val)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'cl-rethinkdb-proto::term))
      (cl:setf (cl:slot-value self 'val) result))
      (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf val) :after (x (self term-assoc-pair))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-val)
  (cl:defgeneric has-val (proto)))
(cl:defmethod has-val ((self term-assoc-pair))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-val)

(cl:unless (cl:fboundp 'clear-val)
  (cl:defgeneric clear-val (proto)))
(cl:defmethod clear-val ((self term-assoc-pair))
  (cl:setf (cl:slot-value self 'val) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-val)



(cl:defclass term (pb:protocol-buffer)
  (
  (type
   :accessor type
   :initform cl-rethinkdb-proto::+term-term-type-datum+
   :type cl-rethinkdb-proto::term-term-type)
  (datum
   :writer (cl:setf datum)
   :initform cl:nil
   :type (cl:or cl:null cl-rethinkdb-proto::datum))
  (args
   :accessor args
   :initform (cl:make-array
              0
              :element-type 'cl-rethinkdb-proto::term
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector cl-rethinkdb-proto::term))
  (optargs
   :accessor optargs
   :initform (cl:make-array
              0
              :element-type 'cl-rethinkdb-proto::term-assoc-pair
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector cl-rethinkdb-proto::term-assoc-pair))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 4))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'term)

(cl:export 'type)


(cl:defmethod (cl:setf type) :after (x (self term))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-type)
  (cl:defgeneric has-type (proto)))
(cl:defmethod has-type ((self term))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-type)

(cl:unless (cl:fboundp 'clear-type)
  (cl:defgeneric clear-type (proto)))
(cl:defmethod clear-type ((self term))
  (cl:setf (cl:slot-value self 'type) cl-rethinkdb-proto::+term-term-type-datum+)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-type)

(cl:export 'datum)

(cl:unless (cl:fboundp 'datum)
  (cl:defgeneric datum (proto)))
(cl:defmethod datum ((self term))
  (cl:let ((result (cl:slot-value self 'datum)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'cl-rethinkdb-proto::datum))
      (cl:setf (cl:slot-value self 'datum) result))
      (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf datum) :after (x (self term))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-datum)
  (cl:defgeneric has-datum (proto)))
(cl:defmethod has-datum ((self term))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-datum)

(cl:unless (cl:fboundp 'clear-datum)
  (cl:defgeneric clear-datum (proto)))
(cl:defmethod clear-datum ((self term))
  (cl:setf (cl:slot-value self 'datum) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-datum)

(cl:export 'args)

(cl:unless (cl:fboundp 'clear-args)
  (cl:defgeneric clear-args (proto)))
(cl:defmethod clear-args ((self term))
  (cl:setf (cl:slot-value self 'args)
           (cl:make-array 0 :element-type 'cl-rethinkdb-proto::term
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-args)

(cl:export 'optargs)

(cl:unless (cl:fboundp 'clear-optargs)
  (cl:defgeneric clear-optargs (proto)))
(cl:defmethod clear-optargs ((self term))
  (cl:setf (cl:slot-value self 'optargs)
           (cl:make-array 0 :element-type 'cl-rethinkdb-proto::term-assoc-pair
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-optargs)


(cl:defmethod cl:print-object ((self term-assoc-pair) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_key: ~s" (key self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_val: ~s" (val self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self term-assoc-pair))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'key) (pb:string-field "")))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'val) cl:nil))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self term-assoc-pair))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:unless (pb:is-initialized (cl:slot-value self 'val))
      (cl:return-from pb:is-initialized cl:nil)))
  cl:t)

(cl:defmethod pb:octet-size ((self term-assoc-pair))
  (cl:let ((size 0))
    ;; optional string key = 1;
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'key))))
        (cl:+ s (varint:length32 s)))))
    ;; optional .Term val = 2;
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'val))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self term-assoc-pair) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional string key = 1;
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'key) 'pb::%octets%))))
  ;; optional .Term val = 2;
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'val) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'val) buffer index limit)))
  index)

(cl:defmethod pb:merge-from-array ((self term-assoc-pair) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; optional string key = 1;
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'key) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional .Term val = 2;
        ((18)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'val)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'cl-rethinkdb-proto::term))
                (cl:setf (cl:slot-value self 'val) message)
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self term-assoc-pair) (from term-assoc-pair))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'key) (cl:slot-value from 'key))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'val)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'cl-rethinkdb-proto::term))
        (cl:setf (cl:slot-value self 'val) message)
        (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'val))))
)



(cl:defmethod cl:print-object ((self term) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_type: ~s" (type self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_datum: ~s" (datum self)))
      (cl:format stream " ~_args: ~s" (args self))
      (cl:format stream " ~_optargs: ~s" (optargs self))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self term))
  (cl:setf (cl:slot-value self 'type) cl-rethinkdb-proto::+term-term-type-datum+)
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'datum) cl:nil))
  (cl:setf (cl:slot-value self 'args)
           (cl:make-array 0 :element-type 'cl-rethinkdb-proto::term
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'optargs)
           (cl:make-array 0 :element-type 'cl-rethinkdb-proto::term-assoc-pair
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self term))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:unless (pb:is-initialized (cl:slot-value self 'datum))
      (cl:return-from pb:is-initialized cl:nil)))
  (cl:let* ((x (cl:slot-value self 'args))
            (length (cl:length x)))
    (cl:dotimes (i length)
      (cl:unless (pb:is-initialized (cl:aref x i))
        (cl:return-from pb:is-initialized cl:nil))))
  (cl:let* ((x (cl:slot-value self 'optargs))
            (length (cl:length x)))
    (cl:dotimes (i length)
      (cl:unless (pb:is-initialized (cl:aref x i))
        (cl:return-from pb:is-initialized cl:nil))))
  cl:t)

(cl:defmethod pb:octet-size ((self term))
  (cl:let ((size 0))
    ;; optional .Term.TermType type = 1;
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'type)))))
    ;; optional .Datum datum = 2;
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'datum))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; repeated .Term args = 3;
    (cl:let* ((v (cl:slot-value self 'args))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    ;; repeated .Term.AssocPair optargs = 4;
    (cl:let* ((v (cl:slot-value self 'optargs))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self term) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional .Term.TermType type = 1;
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (cl:ldb (cl:byte 64 0) (cl:slot-value self 'type)))))
  ;; optional .Datum datum = 2;
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'datum) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'datum) buffer index limit)))
  ;; repeated .Term args = 3;
  (cl:let* ((v (cl:slot-value self 'args))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; repeated .Term.AssocPair optargs = 4;
  (cl:let* ((v (cl:slot-value self 'optargs))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 34))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;// Extension range [10000, 20001)
  ;DO_(_extensions_.SerializeWithCachedSizes(
  ;    10000, 20001, *this, output));

  index)

(cl:defmethod pb:merge-from-array ((self term) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; optional .Term.TermType type = 1;
        ((8)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            ;; XXXXX: when valid, set field, else add to unknown fields
            (cl:setf (cl:slot-value self 'type) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional .Datum datum = 2;
        ((18)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'datum)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'cl-rethinkdb-proto::datum))
                (cl:setf (cl:slot-value self 'datum) message)
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; repeated .Term args = 3;
        ((26)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'cl-rethinkdb-proto::term)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'args)))))
        ;; repeated .Term.AssocPair optargs = 4;
        ((34)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'cl-rethinkdb-proto::term-assoc-pair)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'optargs)))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self term) (from term))
  (cl:let* ((v (cl:slot-value self 'args))
            (vf (cl:slot-value from 'args))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'optargs))
            (vf (cl:slot-value from 'optargs))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'type) (cl:slot-value from 'type))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'datum)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'cl-rethinkdb-proto::datum))
        (cl:setf (cl:slot-value self 'datum) message)
        (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'datum))))
)


